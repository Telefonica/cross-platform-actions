# Table of Contents

* [Usage](#usage)
  * [Assumptions](#assumptions)
  * [Versions](#versions)
  * [Example](#example)
  * [Inputs](#inputs)
  * [Outputs](#outputs)
  * [Debug mode](#debug-mode)
* [Development](#development)
  * [Requirements](#requirements)
  * [Branching model](#branching-model)
  * [Installation](#installation)
  * [Lint](#lint)
  * [Check spelling](#check-spelling)
  * [Check types](#check-types)
  * [Unit tests](#unit-tests)
  * [Build](#build)
  * [Component tests](#component-tests)
  * [Release](#release)
    * [Versioning](#versioning)
    * [Release process](#release-process)

# Usage

This action receives a project name, launches a deploy platform workflow in the corresponding project's platform repository, then it waits for the deploy action to finish and expect it to have uploaded a deploy manifest. Once the deploy workflow has completed successfully, this action returns the deploy manifest as an output.

__So, you can use this action in the project's components repositories to launch the deployment of the project's execution platform, and then get the deploy manifest to use it to deploy the components to the execution environment.__

[![Architecture diagram](./docs/architecture-diagram.png)](./docs/architecture-diagram.png)

1. The component's deploy workflow launches this deploy platform action.
2. This action launches the deploy platform workflow in the project's platform repository.
3. The deploy platform workflow creates the environment in the execution platform and uploads the deploy manifest.
4. This action waits for the deploy platform workflow to finish.
5. This action gets the deploy manifest from the deploy platform workflow artifacts and returns it as an output.
6. The component's deploy workflow gets the deploy manifest from the output and uses it to deploy the components to the execution environment.

## Assumptions

- The target project has a repository named `${project}-platform`, with a deploy workflow named `deploy.yml`. This workflow should create an environment in the execution platform. It must have two inputs:
  * `environment` - Environment to create in the execution platform.
  * `id`: This is a random uuid generated by this action on each execution. You must name a step in your workflow with this id, so that this action can verify that the workflow is the one that was launched by this action.
- The deploy workflow creates a job with a step with `(${{github.event.inputs.id}})` as part of his name. This step will be used to verify that the workflow is the one that was launched by this action. 
- The deploy workflow uploads __only one__ artifact containing just the deployment JSON manifest file.

## Versions

This action adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html). During the release process, tags for the whole version, plus latest, major and minor versions are created, so, you can use next syntax to define the version to use:

* `Telefonica/cross-platform-actions/deploy-platform@v1` - You will use the version `v1.x.x`, keeping up to date with minor and patch releases automatically (recommended).
* `Telefonica/cross-platform-actions/deploy-platform@v1.1` - You will use the version `v1.1.x`, keeping up to date with just patch releases automatically.
* `Telefonica/cross-platform-actions/deploy-platform@v1.1.2` - You will use the version `v1.1.2`, and you will not receive updates automatically.
* `Telefonica/cross-platform-actions/deploy-platform@latest` - You will use the latest version, and you will always receive updates automatically, even if they are major releases containing possible breaking changes (not recommended).

## Example

Example of usage in a component repository:

```yaml
steps:
  - id: deploy-platform
    name: Deploy execution platform
    uses: Telefonica/cross-platform-actions/deploy-platform@{BRANCH_NAME|VERSION}
    with:
      project: $PROJECT_NAME
      environment: $ENVIRONMENT_NAME
      token: $TOKEN
  - name: Azure Login in the execution platform
    run: |
      az login \
        --password ${{ fromJSON(steps.deploy-platform.outputs.manifest).azure.credentials.client_secret }} \
        --service-principal \
        --tenant ${{ fromJSON(steps.deploy-platform.outputs.manifest).azure.credentials.tenant_id }} \
        --username ${{ fromJSON(steps.deploy-platform.outputs.manifest).azure.credentials.client_id }}
  - name: Docker Login in the execution deploy-platform
    run: |
      az acr login \
        --name ${{ fromJSON(steps.deploy-platform.outputs.manifest).registry.name }}
```

## Inputs

- `project` - Project name. This action will launch the deploy workflow in a repository with the name `${project}-platform`.
- `environment` - Environment to create. It will be passed as an input to the deploy workflow.
- `token` - Github token to get access to the repository workflows
- `ref` - _Optional_. Branch or tag in which to run the deploy workflow. If not specified, the `main` branch will be used.
- `repo-suffix` - _Optional_. Suffix to append to the project name to get the platform repository name. If not specified, `-platform` will be used.
- `workflow-id` - _Optional_. ID of the workflow to launch. If not specified, the first workflow with the name `deploy.yml` will be used.

## Outputs

- `manifest` - Manifest generated by the deploy workflow, as a JSON string.

## Debug mode

To enable the debug mode add a repository variable named `ACTIONS_STEP_DEBUG` and set its value to `true`. Debug mode is more verbose and it shows the response of the requests done to the github API.

# Development

## Requirements

* [Node.js](https://nodejs.org/en/) >= 18.x
* [NPM](https://www.npmjs.com/) >= 8.x

## Branching model

This repository uses the trunk-based development branching model. The `main` branch is the main branch (surprise! üòú), and it must be always deployable. All the changes are done in feature branches, and they are merged into `main` using pull requests.

> Note: Even when the main branch should be always deployable, before [declaring a formal release](#release) it may be necessary to perform some manual steps, like updating the changelog or the version number. So, it is recommended to use a release branch to prepare the release.

## Installation

Use NPM to install the dependencies:

```bash
npm i
```

## Lint

This project uses [ESLint](https://eslint.org/) to lint the code. To run it, execute:

```sh
npm run lint
```

It is recommended to install the [ESLint extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) for Visual Studio Code.

Eslint errors can be automatically fixed with `npm run lint:fix`.

## Check spelling

This project uses [cspell](https://github.com/streetsidesoftware/cspell) to check spelling in the code and documentation. To run it, execute:

```sh
npm run check:spelling
```

You can install the [CSpell extension](https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker) for Visual Studio Code to get spell checking in your editor.

## Check types

This project uses [TypeScript](https://www.typescriptlang.org/). You can check types with:

```sh
npm run check:types
```

## Unit tests

Unit tests are written with [Jest](https://jestjs.io/). To run them, execute:

```sh
npm run test
```

The coverage report will be generated in the `coverage` folder.

## Build

‚ö†Ô∏è __IMPORTANT__: For the moment, the project has to be built locally on every change, and the `dist` folder has to be committed to the repository. This is something that we will improve in the future. But, for now, there is a step in the test workflow that checks that the `dist` folder is up to date. So, remember to build the project before pushing your changes, otherwise the tests will fail.

To build the project and add the dist folder, execute:

```sh
npm run build

# Remember to add the built files!!
git add dist
```

## Component tests

Component tests are executed in a real environment, using the GitHub Actions Runner. The action is executed in the workflow, and it dispatches the `deploy-test.yml` workflow in this same repository. The `deploy-test.yml` workflow is a simple workflow that just uploads a fake manifest. The component tests check that the manifest is correctly downloaded by the action and passed as an output.

## Release

### Versioning

All changes must be documented in the [CHANGELOG](./CHANGELOG.md) file. The versioning of the project follows the [Semantic Versioning](https://semver.org/) specification. Here are some basic rules to follow when working on feature branches:

* Do not upgrade the version number in the `package.json` file. The version number is updated in the release process.
* Add changes to the `Unreleased` section of the changelog.

### Release process

To declare a new release, follow these steps:

* Create a release branch from `main` named `release/vX.Y.Z`, where `X.Y.Z` is the version number of the release.
* Update the changelog:
  * Move all the changes from the `Unreleased` section to a new section with the version number and the current date.
  * Add a new `Unreleased` section at the top of the file.
* Update the version number in the `package.json` file.
* Run `npm install` in order to update the `package-lock.json` file.
* Commit the changes and push them to the repository.
* Merge the release branch into `main`.
* __Create a Github release from the main branch__. The release title must be the version number preceded by the `v` letter (`vX.Y.Z`), and the release description must contain the changelog.
* Move the major version tag to the new commit. For example, if the new version is `1.2.3`, move the `v1` tag to the new commit.
* Move the minor version tag to the new commit. For example, if the new version is `1.2.3`, move the `v1.2` tag to the new commit.
* Move the `latest` tag to the new commit.
